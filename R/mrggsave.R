
#' Label, arrange, and save graphics
#'
#' Save plot objects as .pdf file after labeling with Source graphic and
#' Source code labels.
#'
#' @param x an object or list of objects of class `gg`
#' @param script the name of the script generating the `gg` objects
#' @param stem to form the name of the output `.pdf` file
#' @param tag if specified, stem is overwritten by pasting `script`
#' and `tag` together
#' @param dir output directory for `.pdf` file
#' @param prefix gets prepended to the output file path in the Source
#' graphic, label
#' @param onefile passed to [pdf()]
#' @param fontsize for Source graphic and Source code labels
#' @param textGrob.x passed to [grid::textGrob()] (as `x`)
#' @param textGrob.y passed to `textGrob` (as `y`)
#' @param just passed to [grid::textGrob()] (as `just`)
#' @param ypad integer number of newlines to separate annotation
#' from x-axis title
#' @param width passed to [pdf()]; should be less than 5 in.
#' for portrait figure
#' @param height passed to [pdf()]; should be less than 7 in.
#' for portrait figure
#' @param dev one or more devices to use; can pass a character vector or a
#' comma-separated string (e.g. `c("pdf", "png")` or `"pdf,png"`)
#' @param res passed to [png()]
#' @param units passed to [png()]
#' @param position force the graphic annotation to locate to the left or right
#' @param labeller a function that creates the plot annotation; the function
#' should receive a single argument (\code{x}) which is an environment
#' containing various items that might go into the label; pass `NULL` to
#' omit the label on the plot
#' @param .save logical; if `FALSE`, return the labeled objects
#' @param arrange logical; if `TRUE`, arrange the ggplot objects on a
#' single page with [gridExtra::arrangeGrob()]
#' @param ncol passed to [gridExtra::arrangeGrob()]
#' @param labsep character separator (or newline) for Source code and
#' Source graphic labels
#' @param pre_label text to include before annotation; separate lines prior
#' to Source code label; see details
#' @param post_label text to include after annotation; separate lines after
#' Source graphic; see details
#' @param draw if `TRUE`, the plot is drawn using [draw_newpage()]
#' @param use_names if `TRUE`, the names from a list of plots will be used
#' as the stems for output file names
#' @param envir environment to be used for string interpolation in
#' stem and tag
#' @param ... other arguments passed to `mrggsave_common` and then
#' on to [pdf()] and [gridExtra::arrangeGrob()]
#'
#' @details
#' Methods are provided for `ggplot` output, `lattice`
#' output, and `ggmatrix` objects (produced by
#' [GGally::ggpairs()]).  Either a single plot object
#' or a list of objects can be passed in.  If a list of objects
#' are passed in, the plots may be written to a single file (default)
#' or multiple files (if `onefile` is `FALSE`).
#' Alternatively, `ggplots` and `lattice plots`
#' can be arranged on a single page when
#' `arrange` is `TRUE`.  `ggmatrix` objects
#' cannot be arranged.  An error is generated if different
#' object types are passed in a single list.
#'
#' By default, the output file name is generated from
#' the script name and the value in `tag`.  For example,
#' when the script is named `vpc-figures` and the tag
#' is passed as `by-dose-group`, the output file name
#' will be `vpc-figures-by-dose-group.pdf`.  Alternatively,
#' the user can specify the complete stem of the file
#' name with the `stem` argument.
#'
#' Output file names are generated by default with a hyphen (`-`) separator.
#' This can be changed using the function [output_file_sep()].  To
#' revert to previous behavior where the underscore was the separator, call
#' `mrggsave:::output_file_sep("underscore")`.
#'
#' When `.save` is `FALSE`, `mrggsave`
#' always returns a list of table grobs.  If a single
#' plot was passed, the return value in this case
#' is a list of length 1.
#'
#' [mrgglabel()] calls [mrggsave()] and
#' neither draws nor saves the plot, but
#' returns the annotated plots as table grob.
#'
#' `pre_label` and `post_label` are collapsed with newline if
#' supplied by the user, allowing multiple lines to be added before or
#' after the standard annotation.
#'
#' @seealso [mrggdraw()], [mrggsave_list()]
#'
#' @md
#'
#' @examples
#' data(Theoph)
#' require(ggplot2)
#'
#' x <- runif(1000,10,100)
#' y <- 0.3*x + rnorm(length(x),0,20)
#' data <- data.frame(x = x, y = y)
#'
#' Script <- "example.R"
#'
#' # NOTE: see default value for dir argument, which should be appropriate
#' # for project work
#'
#' # Changing it here only for the example
#' options(mrggsave.dir = tempdir())
#'
#'
#' p1 <- ggplot(data=Theoph) +
#'   geom_line(aes(x=Time, y=conc, group=Subject))
#'
#' p2 <- ggplot(data=Theoph) +
#'   geom_line(aes(x=Time, y=conc)) +
#'   facet_wrap(~Subject)
#'
#' mrggsave(p1, Script, "_plot1")
#'
#' \dontrun{
#' mrggsave(p2, Script, "_plot2")
#' }
#'
#' mrggsave(list(p1,p2), Script, "both_plots")
#'
#' \dontrun{
#' mrggsave(list(p1,p2), Script, "separate_files", onefile=FALSE)
#' }
#'
#' mrggsave(p1, Script, "different_shape", width=10, height=4)
#'
#' \dontrun{
#' mrggsave(list(p1,p2), Script, "onepage", arrange=TRUE, ncol=2)
#'
#' stopifnot(require(GGally))
#'
#' p3 <- ggpairs(data)
#'
#' mrggsave(p3, Script, "ggally_plot")
#' }
#' @export
mrggsave <- function(x, ...) {
  UseMethod("mrggsave")
}

#' @rdname mrggsave
#' @export
mrggsave.ggplot <- function(x, ..., ypad = 2,
                            arrange = FALSE,
                            ncol = 1,
                            onefile = TRUE,
                            envir = parent.frame()
                            ) {

  if(ncol > 1) arrange <- TRUE

  if(!inherits(x,"list")) {
    x <- list(x)
  }

  if(arrange) {
    onefile <- TRUE
    x <- gList(arrangeGrob(grobs=x, ncol = ncol, ...))
  }

  mrggsave_common(
    x = x, ypad = ypad, onefile = onefile, arrange = arrange,
    envir = envir,  ...
  )
}

#' @rdname mrggsave
#' @export
mrggsave.ggmatrix <- function(x, ..., ypad = 4, arrange = FALSE,
                              onefile = TRUE, envir = parent.frame()) {

  if(!inherits(x,"list")) {
    x <- list(x)
  }

  x <- lapply(x, mrggsave_prep_object.ggmatrix)

  if(arrange) {
    onefile <- TRUE
    x <- gList(arrangeGrob(grobs=x,...))
  }

  mrggsave_common(
    x = x, ypad = ypad, arrange = arrange, envir = envir, ...
  )
}

#' @rdname mrggsave
#' @export
mrggsave.gList <- function(...) {
  mrggsave_common(...)
}

#' @rdname mrggsave
#' @export
mrggsave.gtable <- function(...) {
  mrggsave.ggplot(...)
}

#' @rdname mrggsave
#' @export
mrggsave.trellis <- function(x, ..., ypad = 3, arrange = FALSE, ncol = 1,
                             onefile = TRUE, envir = parent.frame()) {

  if(ncol > 1) arrange <- TRUE

  if(!inherits(x,"list")) {
    x <- list(x)
  }

  if(arrange) {
    onefile <- TRUE
    x <- lapply(x, arrangeGrob)
    x <- gList(arrangeGrob(grobs = x, ncol = ncol, ...))
  }

  mrggsave_common(
    x = x, ypad = ypad, arrange = arrange, onefile = onefile,
    envir = envir, ...
  )
}

#' @rdname mrggsave
#' @export
mrggsave.patchwork <- function(x,  ..., envir = parent.frame()) {
  assert_that(requireNamespace("patchwork"))
  mrggsave(patchwork::patchworkGrob(x),..., envir = envir)
}

#' @export
mrggsave.ggsurvplot <- function(x, ..., envir = parent.frame()) {
  mrggsave_common(mrggsave_prep_object(x), ..., envir = envir)
}

#' @rdname mrggsave
#' @export
mrggsave.list <- function(x, ..., arrange = FALSE,
                          use_names = FALSE, envir = parent.frame()) {

  if(inherits(x, "named-plots")) use_names <-  TRUE

  if(use_names) {
    stem <- names(x)
    if(is.null(stem)) {
      stop("the plot list must be named when `use_names` is TRUE.", call.=FALSE)
    }
    if(!all(nchar(stem) > 0)) {
      stop("all plot names must at least one character.", call.=FALSE)
    }
    args <- list(...)
    args$arrange <- arrange
    tag <- args$tag
    args$tag <- NULL
    args$envir <- envir
    context <- NULL
    if(inherits(x, "needs-context")) {
      context <- args$script
      if(is.null(context)) {
        mrg.script <- getOption("mrg.script", context)
        context <- getOption("mrggsave.use.context", mrg.script)
      }
      context <- no_r_ext(context)
    }
    ans <- lapply(seq_along(x), function(i) {
      args$stem <- paste0(c(context,stem[i],tag), collapse = .sep())
      args$x <- x[[i]]
      do.call(mrggsave, args)
    })

    if(getOption("mrggsave.return.more", FALSE)) {
      names(ans) <- stem
      return(invisible(ans))
    }

    return(invisible(unlist(ans, use.names = FALSE)))
  }

  x <- flatten_plots(x)

  cl <- scan_list_cl(x)

  if(all(cl$cl == "gg-ggplot")) {
    return(mrggsave.ggplot(x, arrange = arrange, ..., envir = envir))
  }

  if(all(cl$cl == "trellis")) {
    return(mrggsave.trellis(x, arrange = arrange, ..., envir = envir))
  }

  if(all(cl$ggmatrix)) {
    return(mrggsave.ggmatrix(x, arrange = arrange, ..., envir = envir))
  }

  x <- lapply(x, mrggsave_prep_object)

  mrggsave.ggplot(x, arrange = arrange, ..., envir = envir)
}

#' @rdname mrggsave
#' @export
mrggsave.gg <- function(x, ...) {
  NextMethod()
}

#' @rdname mrggsave
#' @export
mrggsave.gTree <- function(x, ..., envir = parent.frame()) {
  mrggsave_common(mrggsave_prep_object(x), ..., envir = envir)
}

#' @export
#' @rdname mrggsave
mrgglabel <- function(..., draw = FALSE, .save = FALSE) {
  mrggsave(..., draw = FALSE, .save = FALSE)
}

eps <- function(...) {
  postscript(..., paper = "special", onefile = FALSE, horizontal = FALSE)
}

#' @rdname mrggsave
#' @export
mrggsave_common <- function(x,
                            script = getOption("mrg.script", NULL),
                            tag = NULL,
                            width = 5, height = 5,
                            stem = "Rplot",
                            dir = getOption("mrggsave.dir","../deliv/figure"),
                            prefix = NULL,#gsub("^\\.\\./","./",dir),
                            onefile = TRUE,
                            arrange = FALSE,
                            draw = FALSE,
                            .save = TRUE,
                            ypad = 3,
                            labsep = "\n",
                            pre_label = NULL,
                            post_label = NULL,
                            fontsize = 7,
                            textGrob.x = 0.01,
                            textGrob.y = unit(0.1,"in"),
                            just = c('left','bottom'),
                            dev = getOption("mrggsave.dev", "pdf"),
                            res = 150,
                            units = "in",
                            position = getOption("mrggsave.position", "default"),
                            labeller = getOption("mrggsave.label.fun", label.fun),
                            envir = parent.frame(sys.nframe()),
                            ...) {

  check_dir(dir)

  stopifnot(is.character(dev))
  dev <- cvec_cs(dev)
  more_dev <- NULL
  if(length(dev) > 1) {
    more_dev <- dev[-1]
    dev <- dev[1]
  }

  n  <- length(x)

  if(dev %in% c("pdf", "cairo_pdf")) {
    onefile <- onefile | n==1
  } else {
    onefile <- length(x)==1
  }

  ext <- gsub("cairo_pdf", "pdf", dev, fixed = TRUE)
  ext <- paste0(".", ext)

  if(is.null(script)) {
    stop(
      c("please specify the script name either as an argument (`script`) ",
        "or an option (`mrg.script`)"),
      call. = FALSE
    )
  }

  if(!is.null(tag)) {
    context <- getOption("mrggsave.use.context", script)
    stem <- make_stem(context, tag)
  } else {
    stem <- paste0(stem, collapse = .sep())
  }

  stem <- glue(stem, .envir = envir)

  if(isTRUE(getOption("mrggsave.file.tolower", FALSE))) {
    stem <- tolower(stem)
  }

  if(!onefile) {
    pdffile <- paste0(file.path(dir,stem),"%03d", ext)
    file <- paste0(stem,sprintf("%03d", seq(n)), ext)
    if(is.character(prefix)) file <- file.path(prefix, file)
    outfile <- sprintf(pdffile, seq(n))
  } else {
    pdffile <- paste0(file.path(dir,stem), ext)
    file <- paste0(stem, ext)
    if(is.character(prefix)) file <- file.path(prefix, file)
    outfile <- pdffile
    if(n > 1) file <-  paste(file, "page:", seq(n))
  }

  pad <- paste0(rep("\n", as.integer(ypad)), collapse = "")

  d <- list2env(
    list(
      pad = pad,
      pre_label = pre_label,
      post_label = post_label,
      source_code = script,
      labsep = labsep,
      source_graphic = file,
      n = n,
      file = pdffile,
      position = position,
      textGrob.x = textGrob.x,
      textGrob.y = textGrob.y,
      fontsize = fontsize,
      just = just
    ),
    parent = .GlobalEnv
  )

  label <- labeller(d)

  if(length(label) != n) {
    nn <- length(label)
    stop("'label' must be length ",n ," (not ",nn,")", call.=FALSE)
  }

  position <- match.arg(d$position, c("default", "left", "right"))
  if(position != "default") {
    if(position=="left") {
      d$just <- c("left", "bottom")
      d$textGrob.x <- unit(0.015, "npc")
    }
    if(position=="right") {
      d$just <- c("right", "bottom")
      d$textGrob.x <- unit(0.985, "npc")
    }
  }

  x <- annotate_graphic(x, d, labeller)

  if(draw) {
    if(is_glist(x)) {
      draw_newpage(x)
    } else {
      .foo <- lapply(x,draw_newpage)
    }
  }

  if(!.save) {
    return(invisible(x))
  }

  args <- list(
    onefile = onefile, width = width, height = height, res = res,
    units = units, file = pdffile, filename = pdffile
  )

  if(dev=="eps") {
    dev <- "postscript"
    args$paper <- "special"
    args$onefile <- FALSE
    args$horizontal <- FALSE
  }

  if(dev=="ps") {
    dev <- "postscript"
  }

  args <- c(args, list(...))
  args <- args[names(args) %in% names(formals(dev))]

  do.call(dev, args)
  for(i in seq_along(x)) {
    grid.arrange(x[[i]])
  }
  grDevices::dev.off()

  if(!is.null(more_dev)) {
    this_call <- match.call()
    for(d in more_dev) {
      this_call$dev <- d
      this_outfile <- eval(this_call, sys.frame(-1))
      outfile <- c(outfile, this_outfile)
    }
  }

  if(getOption("mrggsave.return.more", FALSE)) {
    x <- list(
      outfile = outfile,
      label = d$label,
      source_graphic = d$source_graphic,
      source_code = d$source_code
    )
    return(invisible(x))
  }
  return(invisible(outfile))
}

annotate_graphic <- function(x, d, labeller) {
  if(!is.function(labeller)) {
    d$label <-  rep("", d$n)
    return(lapply(x, arrangeGrob))
  }
  d$label <- labeller(d)
  if(length(d$label) != d$n) {
    nn <- length(d$label)
    stop("`label` must be length ", d$n," (not ", nn, ")", call. = FALSE)
  }
  for(i in seq_along(x)) {
    x[[i]] <- arrangeGrob(
      x[[i]],
      bottom = textGrob(
        gp = gpar(fontsize = d$fontsize),
        just = d$just,
        y = d$textGrob.y,
        x = d$textGrob.x,
        label = d$label[[i]]
      )
    )
  }
  x
}

scan_list_cl <- function(x) {
  cl <- lapply(x, class)
  cl <- unlist(lapply(cl, paste, collapse = "-"), use.names=FALSE)
  list(ggmatrix = cl == "gg-ggmatrix", cl = cl)
}

#' Save the last plot using mrggsave
#'
#' @param stem passed to [mrggsave()]
#' @param script passed to [mrggsave()]
#' @param ... passed to [mrggsave()]
#' @param envir environment to be used for string interpolation in
#' stem and tag; passed to [mrggsave()]
#'
#' @md
#' @export
mrggsave_last <- function(stem, script = getOption("mrg.script", NULL), ...,
                          envir = parent.frame()) {
  mrggsave(last_plot(), stem = stem, script = script, ..., envir = envir)
}
